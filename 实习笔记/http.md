# 1. web 及网络基础

## 1.1url 和 uri

* uri(uniform resource identifier, 统一资源标识符)
    uri 表示由某个协议方案表示的资源的定位标识符。
* url(统一资源定位符)
    表示资源的地点，因此 url 是 uri 的子集

一个是身份证号，一个是家庭地址。什么意思呢，身份证号可以唯一的表示一个人，但是并不一定能够找到那个人，家庭地址也可以表示一个人，并且可以找到他。

# 2.http 基础

## 2.1 请求响应报文结构

![img](https://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png)

请求报文如图，请求行标识了请求方法、uri 以及使用的 http 协议版本。然后是请求头部的内容，对请求进行补充说明，最后是请求数据。

![img](https://www.runoob.com/wp-content/uploads/2013/11/httpmessage.jpg)

响应报文如图，状态行标识协议版本，以及响应状态码和对应短语。然后是消息报头进一步说明响应格式，一个空行标识分隔，然后就是响应正文。

## 2.2 请求方法

* GET: 获取资源，用来请求访问被 uri 标识的资源。
* POST:传输实体主体，虽然 GET 也可以传输，但一般都采用 POST 传输，POST 的主要目的不是获取响应，而是传输主体给服务器。
* PUT:传输文件到 uri 指定的位置。
* DELETE:删除资源文件，是 PUT 的反方法。

## 2.3 长连接

在初始的 http 的版本，每进行一次 http 通信，就要断开一次 TCP 连接。开始因为请求的资源数通常不会很多，所以问题不大。但现在网页越来越复杂，包含众多的图片等资源，浏览器也需要请求这些资源，因此每次都新开个 TCP 连接通信开销就变大了。

为了解决这个问题，提出了长连接的方案，在请求字段加入 connection: keep-alive，表明开启，1.1 默认开启。这样，会保持连接知道对端关闭，或者一定时间后关闭。

使用了长连接，使得浏览器可以实现管线化的操作，浏览器可以并行的发出多个请求，而不需要一个个等待响应。

## 2.4 Cookie

因为 http 被设计为无状态的协议，所以在比如一些登录的时候，就不是很方便，需要一些能够记录状态的功能，因此出现了 cookie 技术。

首先当没有 cookie 的时候，服务端会返回一个叫做 Set-Cookie 的首部字段信息，来通知客户端保存 cookie。下次发送请求时，客户端就会带着这个cookie，服务器也就知道发送请求的是哪个用户了。

# 3. HTTP 报文内的信息

## 3.1 获取部分内容的范围请求

有时候指向获取信息的部分内容，可以利用 Range 首部字段，来节约带宽，形势如下

```
Range: bytes=5001-10000 // 获取 5001~10000 字节
Range: bytes=5001- // 获取 5001 之后的内容
```

针对范围请求，状态码返回 206 Partial Content 报文。

## 3.2 状态码

| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| ---- | ---------------------------------------------- |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

# 4. 与 HTTP 协作的 Web 服务器

## 4.1 通信转发程序

* 代理：服务端和客户端之间的中间角色，接收客户端请求发送给服务端，也接收服务端消息并转发给客户端
* 网关：转发其他服务器通信数据的服务器，接收客户端请求时，他就像自己拥有资源的服务器一样对请求进行处理。
* 隧道：在相隔甚远的 c/s 进行中转，并保持双方通信。

# 5. HTTPS

HTTP 的不足：

* 明文通信，有被窃听的风险
* 没有验证通信方身份，有被伪装的风险
* 无法验证报文完整性，可能再链路中被篡改

对于问题 1，采用 SSL 加密来解决。且通过证书，可以认证通信方的身份。通过哈希值进行校验，可以一定程度上保证结果没有被篡改。因此，可以说 HTTPS= HTTP + 加密 + 认证 + 完整性保护。

## 5.1 加密技术

* 共享秘钥技术

  加密和解密采用同一套秘钥的方式，可是怎么安全的传输秘钥本身是个问题。。。

* 公开密钥加密

  这种方式，加密用的是公钥，解密用的是私钥，很好的避免了秘钥传输的问题，即使窃听到公钥，没有私钥也很难恢复出信息。

HTTPS 采用混合模式，先通过公开秘钥的方式，交换共享秘钥的秘钥，再使用共享秘钥加密的方式通信。

这么做主要是因为公钥方式，处理起来更为复杂，效率低，在确保安全的情况下，可以使用效率更高的方式。

## 5.2 证书

公钥加密可以解决问题 1，但是没办法证明公钥就是准备通信的服务器的公钥，有可能再途中已经被替换掉了。

证书就是用来解决这一问题的，首先，服务器人员需要想 c/s 两端都信任的第三方数字证书认证机构(CA)，提交申请，机构会对公钥和相关信息用机构的私钥加密，形成一份证书。

服务器发送这个证书给客户端，客户端使用 CA 的公钥解密证书，对签名进行验证，客户端就可确认服务器的公钥是值得信任的。由于CA 的公钥有可能再传输中被替换，一般来说，会在内部植入 CA 的公钥。

# 6. 确认访问用户身份

1. BASIC 认证

   * 客户端请求需要认证的资源时，服务端返回 401 表示要认证身份。
   * 在请求首部加上以 Base64 方式编码的 Autheorization: account:password。
   * 服务端验证通过，则返回对应资源

   缺点：

   * 明文发送
   * 一般浏览器无法注销

2. DIGEST 认证 (http/1.1开始)

   * 客户端请求需要认证的资源时，服务端返回 401 表示要认证身份，并发送质询码(nonce，随机数)，此外 WWW-Authenticate 必须包含re'alm 以及 nonce 信息
   * 客户端返回信息首部字段 Autheorization 必须包含，username、realm、nonce、uri 和 response 的信息。response 是响应码，是根据运算产生的。
   * 服务端确认认证信息，并返回。

   不灵活，且安全性还是不够高，用的也很少

3. SSL 客户端认证

   * 客户端必须事先安装需要的证书
   * 服务器收到要认证的资源，发送 Certificate Request 报文，要求认证证书
   * 客户端发送证书给服务器，服务器认证证书后，得到公钥，开始 HTTPS 通信。

   通常会和表单认证组合一起认证。

4. 基于表单认证

   * 用户请求访问某个受保护的资源
   * 服务器发现用户尚未认证，返回一个包含需填写认证信息的表单的HTML页面
   * 用户填写用户名和密码并提交给服务器
   * 服务器验证用户信息，如若成功则为当前用户创建一个“Session”，并将session id放到cookie中，之后这个用户的所有请求都会带上这个cookie，这样服务器就可以拿到cookie中的session id将其与服务器端保存在内存里的session id比较进行认证。
   * 当用户退出登录时，Session被销毁，服务器端保存的session id被移除。之后的请求需要重新进行验证。

   使用HTTP的Form-based认证中所有的认证信息也都是明文传输的，在这一点上Form-based的安全性并不比Basic认证高，仍然需要与加密传输（比如HTTPS）配合使用。Form-based认证的优势主要在于认证成功后服务器端维护了与用户之间的会话信息，无论是用户主动退出登录还是一定时间后服务器可认为会话超时，在“登出”操作上Form-based认证会比HTTP Basic认证处理得更安全。

5. token-based 认证([token-base](https://liaodanqi.me/2018/10/23/token-authentication/))

   session 认证有着一些问题：

   * 用户量大的时候，服务端保存资源多
   * 分布式部署，打到多台服务器可能有问题

   Token-based认证的最大特点就是**服务器实现无状态化**，这是如何实现的呢？
   当用户第一次认证成功后，把必要的用户验证信息和一些其他有用的信息（比如token有效期）使用服务端密钥签名后生成一个token返回给客户端。之后每次客户端的每次请求都带上这个token，所有用于用户认证的需要的信息都在这个token（self-contained）中，服务器只需要验证token是否合法即可。

# 7. Question

1. cookie 和 session 的区别

   * 因为 http 被设计为无状态的协议，所以在比如一些登录的时候，就不是很方便，需要一些能够记录状态的功能，因此出现了 cookie 技术。

   首先当没有 cookie 的时候，服务端会返回一个叫做 Set-Cookie 的首部字段信息，来通知客户端保存 cookie。下次发送请求时，客户端就会带着这个cookie，服务器也就知道发送请求的是哪个用户了。

   * Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。

   也就是说，cookie 是在客户端处，保存回话的状态，session 是保存在服务器端。(因此，session 要考虑在多机上一致性的问题，可以在多机间复制，也可以采用讲 sessionid 放入缓存中，服务器都从缓存中查询。不管怎么说，session 都给服务器带来了额外的负担。)

   

   token 就出现了，他相当于在客户端存储，但是在服务端验证，服务端压力小，又能起到相同的作用。

   