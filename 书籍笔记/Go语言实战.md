# Go语言实战

因为已经阅读过基本Go相关的基础资料，本书中已经掌握、比较基础的就不会再进行记录了

## 1.数组、切片和映射

### 三个索引创建切片

可以通过两个索引slice[i:j]创建切片，此外，还可以通过三个索引创建切片，slice[i:j:k]意味着从i开始，长度为j-i，容量为k-i的切片

这种方式，我们可以创建长度和容量相同的切片，然后通过append进行新的内存分配，从而脱离和原数组之间的关系

go的range循环返回的是index和元素的拷贝

### 映射

映射底层是hash实现的，因此需要key是能够比较的即可。但是切片、函数以及包含切片的类型，都是不能作为key的，因为他们是引用类型，key之后可能会改变。

作为value，什么都可以

可以通过声明一个未初始化的映射创建一个nil映射，这个映射不能用于存储任何键值对

映射是引用类型，在函数见传递的是引用

## 2.Go的类型系统

### 引用类型

go中的引用类型有：切片、映射、通道、接口和函数类型。

### 接口和多态

多态本质是可以根据类型的实现，而采取不同行为的能力，在go中主要是通过接口实现的

* 接口实现  
    接口是用来定义行为的类型，如果一个用户类型（实体类型）实现了某个接口类型声明的一组方法，那么这个实体就可以被赋给接口的值

    由于不同实体类型的方法不一样，因此对接口值方法的调用自然是一种多态

    接口变量的值由两部分组成，一个是指向内部表(iTable，包含了存储的值的类型信息和关联的一组方法)的指针，另一个是指向所存储的值的指针

* 方法集  
    规范中定义了方法集的描述
    |值|接收者|
    |:---:|:---:|
    |T|t T|
    |*T|t T 和 t *T|

    那么也就是说，如果接受者是T，则值类型是什么皆可，如果是指针，则只能传入指针了

    所以，在我们调用接口方法是需要注意方法集的对应，这主要是因为，我们并不总是能获取值的地址，所以对于值类型，只包括了接收者为值的情况

### 接口和多态

除了多态和封装，继承也是面向对象编程的一大特点。继承可以复用已经实现的类，减小代码量。

go中和cpp不同，这方面功能是通过嵌入类型实现的，被嵌入的类型的方法也会被提升到外部类型，当然，go也支持对方法进行重写

因为外部类型嵌入了内部类型后，内部类型的方法会被提升至外部类型，所以外部类型同样实现了这一接口

如果外部类型进行了重写方法，那么内部类型的方法就不会被提升，但是，可以通过访问内部类型来访问方法，内部类型本身方法不会消失

## 3.并发

### 锁住共享资源

go提供了便捷的方式实现并发，因此如果处理不当，就会发送race condition

* 原子函数  
    sync/atomic包中封装了一些原子函数，可以对变量进行原子的操作，如AddInt64，LoadInt64和StoreInt64等
* 用sync.Mutex等锁方法维护临界区也可以保护共享资源

### 通道

除了传统的原子操作和锁，go提供了通道的方式，通过发送和接收需要的共享资源，达到同步的目的

## 4.并发模式

runner包可以监视程序执行时间，也可以设置超时时间进行关闭

### sync.Pool

由于申请和释放的代价比较高，完全以来gc的话，可能会降低程序的效率，对于经常释放申请的对象，常常使用内存池进行管理，减小开销

go官方提供了sync.Pool来实现

主要有几个方法：  
* Get  
    从池中获取对象时，选择策略遵循：  
    * 优先从 private 中选择对象
    * 若取不到，则对 shared slice 加锁，取最后一个
    * 若取不到，则尝试从其他线程中 steal
    * 若还是取不到，则使用 New 方法新建
    
* Put
    Put的过程则相对简单，只需要将对象放回到池中。与取出一样，放回同样拥有策略：
    * 优先放入 private
    * 如果 private 已经有值，即不能放入，则尝试放入 shared

详细见[sync.Pool研究](https://changkun.us/archives/2018/09/256/)



>Golng 提供了不少打印函数，基本上分为三类三种。即 Print Println 和Printf。
Print比较简单，打印输出到标准输出流，Println则也一样不同在于多打印一个换行符。至于Printf则是打印格式化字符串，三个方法都返回打印的bytes数。Sprint，Sprinln和Sprintf则返回打印的字符串，不会输出到标准流中。Fprint，Fprintf和Fprinln则把输出的结果打印输出到io.Writer接口中，http中则是http.ReponseWriter这个对象中，返回打印的bytes数。



