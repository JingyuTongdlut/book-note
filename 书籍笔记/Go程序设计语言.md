- [Go程序设计语言](#go%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e8%af%ad%e8%a8%80)
  - [1.程序结构](#1%e7%a8%8b%e5%ba%8f%e7%bb%93%e6%9e%84)
    - [名称](#%e5%90%8d%e7%a7%b0)
    - [声明](#%e5%a3%b0%e6%98%8e)
    - [变量](#%e5%8f%98%e9%87%8f)
    - [类型声明](#%e7%b1%bb%e5%9e%8b%e5%a3%b0%e6%98%8e)
  - [2.基础数据类型](#2%e5%9f%ba%e7%a1%80%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b)
    - [常量](#%e5%b8%b8%e9%87%8f)
  - [3.复合数据类型](#3%e5%a4%8d%e5%90%88%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b)
    - [数组](#%e6%95%b0%e7%bb%84)
    - [slice切片](#slice%e5%88%87%e7%89%87)
    - [map](#map)
    - [结构体](#%e7%bb%93%e6%9e%84%e4%bd%93)
  - [4.函数](#4%e5%87%bd%e6%95%b0)
    - [变长函数](#%e5%8f%98%e9%95%bf%e5%87%bd%e6%95%b0)
    - [推迟执行(defer)](#%e6%8e%a8%e8%bf%9f%e6%89%a7%e8%a1%8cdefer)
  - [5.方法](#5%e6%96%b9%e6%b3%95)
    - [方法声明](#%e6%96%b9%e6%b3%95%e5%a3%b0%e6%98%8e)
    - [指针接受者的方法](#%e6%8c%87%e9%92%88%e6%8e%a5%e5%8f%97%e8%80%85%e7%9a%84%e6%96%b9%e6%b3%95)
    - [匿名成员](#%e5%8c%bf%e5%90%8d%e6%88%90%e5%91%98)
    - [封装](#%e5%b0%81%e8%a3%85)
  - [6.接口](#6%e6%8e%a5%e5%8f%a3)
    - [接口类型](#%e6%8e%a5%e5%8f%a3%e7%b1%bb%e5%9e%8b)
    - [接口值](#%e6%8e%a5%e5%8f%a3%e5%80%bc)
    - [error接口](#error%e6%8e%a5%e5%8f%a3)
    - [类型断言](#%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80)
  - [7.goroutine和通道](#7goroutine%e5%92%8c%e9%80%9a%e9%81%93)
    - [goroutine](#goroutine)
    - [通道](#%e9%80%9a%e9%81%93)
    - [select多路复用](#select%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8)
  - [8.共享变量](#8%e5%85%b1%e4%ba%ab%e5%8f%98%e9%87%8f)
    - [互斥锁](#%e4%ba%92%e6%96%a5%e9%94%81)
    - [读写锁](#%e8%af%bb%e5%86%99%e9%94%81)
    - [延迟初始化sync.Once](#%e5%bb%b6%e8%bf%9f%e5%88%9d%e5%a7%8b%e5%8c%96synconce)
    - [goroutine与线程（重要！！！）](#goroutine%e4%b8%8e%e7%ba%bf%e7%a8%8b%e9%87%8d%e8%a6%81)
  - [9.反射](#9%e5%8f%8d%e5%b0%84)
    - [Type和Value](#type%e5%92%8cvalue)
# Go程序设计语言

## 1.程序结构

### 名称

实体在函数中声明则只在函数内有效

声明在函数外，则在包内所有源文件可见，首字母大小写决定是否可以跨包可见。大写开头则是导出的，包外可见可访问，反之则不行。

包名都是小写的，Go中习惯采用驼峰的命名风格

### 声明

4个主要声明，变量（var）、常量（const）、类型（type）和函数（func）

文件以package声明开头，表明文件属于哪个包

紧跟的是import声明，导入需要的包

### 变量

`var name type = expression`
类型和表达式可以省略一个，但是不能都省略，因为需要二者之一决定类型和值。省略exp，则表达式为零值。

在函数内，可以用短变量声明进行声明和初始化`name := expression`，因为这种方式短小，简洁，所以局部变量一般采用这种形式。短变量声明至少要有一个新变量，否则会报错

可以通过变量列表的方式进行声明`var name1, name2, name3 = val1, val2, val3`

通过`var name *type = &name1`可以声明指针，和c中不同，go中返回局部变量的指针是合法的，通过预声明的函数new可以声明一个变量，并返回其地址

**变量的声明周期：** 包级别变量的生命周期是整个程序的生命周期，局部变量的生命从被创建实体，到他不能够被访问，这时局部变量占用的存储空间会被回收

### 类型声明

go提供了取别名的方式增加可读性（类似typedef），形式为：`type name underlying-type`，通常在包级别进行，如果name为可导出的，则包外可见

## 2.基础数据类型

### 常量

用const关键字声明，如果声明一组常量，除第一个外的表达式可以省略，后续值为之前的值。

用iota生成器，从0开始，逐项+1，如
```go
const (
    Sunday int = iota
    Monday 
    ...
)
```

此外，常量可以是无类型的，他们的精度比基本类型精度高，可以认为至少是256位的。例如math.Pi如果一开始就确定精度，则可能导致精度下降。

## 3.复合数据类型

将基本数据类型以各种方式组合而构成，分别是数组、slice、map和结构体。

### 数组

数组是长度固定，且拥有零个或多个相同类型元素的序列，长度固定，很少直接使用

```go
var a [3]int //3个整数的数组
var a [3]int = [3]int{1, 2} //用列表进行初始化
a := [...]int{1, 2, 3} //根据初始化列表确定数组的个数
```

如果数组内的元素可比较，那么数组也是可比较的，==操作用来比较连个数组元素值是否完全相同，用！=比较是否不同

go和c不一样，数组传参是值传递，效率很低，可以显示的传递数组指针，但更多情况，我们使用slice

### slice切片

slice表示一个拥有相同类型元素的可变长度的序列，写为`[]T`

slice可以用来访问数组的部分或全部元素，slice有三个属性，指针，长度和容量

如果slice超过的长度，则最终的slice会更长，但是如果超过了底层的容量，那么会导致程序崩溃

调用内置函数make可以创建一个具有制定元素类型，长度和容量的slice`make([]T, len, cap)`，其实，make就是创建了一个匿名数组，并且返回了一个他的slice

* append函数
    append用于将元素追加到slice的后面
    append策略类似cpp中vector的push_back，均摊复杂度较低

### map

key-value数据类型，和cpp中的map类似，底层都是hash实现

内置函数make可以创建一个map，`ages := make(map[string]int)`

使用内置的delete函数删除一个元素`delete(ages, "alice")`，该操作及时key不存在，也是安全的

go没有提供set，但是可以利用map的value设为bool类型实现

### 结构体

和结构体是将零个或多个任意类型组合的聚合类型，类似struct

访问成员通过`.`实现，为了简化代码，指针访问成员不需要像c一样解引用

结构体的成员变量是否导出，也是通过首字母大小写来确定的

结构体的零值由成员的零值构成

结构体初始化，可以按顺序，为每个变量指定值，但是这种方法可读性很差，一般通过指定部分成员变量的名称和值进行初始化

大型结构体传参一般传递指针以减少复制

* 结构体嵌套  
  go允许结构体中嵌套结构体，通过a.b.c的方式进行访问
* 匿名成员
  多级嵌套结构体，访问太繁琐，go中可以定义不带名的匿名成员变量，这样我们就可以直接通过a.c，不用通过中间变量b了

## 4.函数

函数声明包括一个名字，一个形参列表，一个可选的返回列表以及函数体
```go
func name(parameter-list) (result-list) {
    body
}
```

实参是按值传递的，如果没有函数体的声明，这说明函数是用别的语言实现的

### 变长函数

在参数列表的最后类型名称之前用...表示声明一个边长函数，在接收时可以接收不等数量的参数个数，以slice形式，传递到函数形参

调用时，如果是参数，照常即可，如果是一个slice，实参+...进行调用

### 推迟执行(defer)

采用defer语句，可以使指令推迟到函数结束后再调用，通常用于成对的情况，比如打开和关闭等，保证资源能够被正确的释放(**感觉这里类似RAII的思想吧**)

## 5.方法

### 方法声明

```go
func (p Point) Distance(q point) folat64 {
    return math.Hypot(q.X - p.X, q.Y - p.Y)
}
```
此处，p为消息的接收者，和cpp不一样，没有采用this作为接受者而是自己选择名字，一般选择类型首字母

### 指针接受者的方法

如果方法需要更新接受者的内容，或者不希望复制整个参数，可以将接受者设为指针类型
```go
func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}
```
该方法的名字是(*Point).ScaleBy，习惯上，如果某一个方法设定为指针接受者，则应该全部都设为指针接受者

本身是指针的类型，不允许进行方法声明，在调用时，指针也可以直接用.访问方法

### 匿名成员

通过匿名字段定义的成员变量的方法，也可以被含有该匿名成员的结构体调用

是指针形式也可以

### 封装

go中封装的单元是包而不是类型，在同一包内，不论首字母大小写都是可见的

在go中，也是通过结构体进行封装的，从而控制成员在其他包的可见性

## 6.接口

### 接口类型

一个接口类型定义了一套方法，如果一个类型要实现该接口，那么必须实现该接口的所有方法

```go
type Reader interface {
    method
}
```
### 接口值

接口类型的值有两部分，一个是具体类型，还有该类型的值

接口值为nil和含有nil值的非空接口是不一样的

### error接口

error实际上是一个接口类型，包含一个返回错误消息的方法
```go
type error interface {
    Error() string
}
```

### 类型断言

类似于`x.(T)`，如果T是一个具体类型，则类型断言会检查x的动态类型是否为T，如果是，结果会返回动态值，失败，则崩溃

如果T是一个接口类型，则会检查x是否满足T，如果成功，则返回T接口类型

如果不想在失败时，程序崩溃（用来检验类型），可以用两个返回值接收`f, ok = x.(T)`，如果ok为false，则失败

## 7.goroutine和通道

### goroutine

goroutine编程方式类似线程，程序启动时，有一个主goroutine启动面函数，要启动其他goroutine，只要go + function即可

main函数退出时，会强制中断所有其他的goroutine

### 通道

通道是不同goroutine之间的连接，每一个通道都带有一个元素类型，一个int类型的通道写为`chan int`

通过make创建通道`ch := make(chan int)`创建一个通道

通道是双向通信的，操作如下
```go
ch <- x //发送x到ch
x = <- ch //接收ch到x
<- ch //接收ch，丢弃
```

使用`close(ch)`来关闭通道

* 无缓冲通道  
    使用make创建的，默认是无缓冲的通道，不过make还可以接收第二个参数，来设置通道容量的整数
    ```go
    ch := make(chan int)
    ch := make(chan int, 0)
    ```

    对于无缓冲通道，发送放会阻塞，直到被另一个goroutine接收，接收端也会阻塞，直到另一个goroutine发送
* 通道状态判断  
    `x, ok := <-ch`，通过ok状况，判断接收情况，从而判断通道是否被关闭
* 单向通道  
    有时候需要限制数据流向是单向的，事实上基本上总是限制为单向的
    ```go
    chan<- int //只能发
    <-chan int //只能收
    ```
* 缓冲通道
    利用make的第二个参数，可以创建缓冲通道，如`ch := make(chan string, 3)`，创建了三个字符串的缓冲通道

    对于读操作，如果缓冲通道是空的则阻塞，否则可以读取。对于写操作，如果缓冲通道是满的，则阻塞，如果缓冲通道可写，则写入

### select多路复用

go从语言层面提供了多路复用的语法，类似c的select。

```go
select {
    case <-ch1:
    //...
    case x := <-ch2:
    //...
    default:
    //...
}
```

select默认会一直等待，如果想要类似epoll等实现定时等待，可以利用time.After函数返回的通道，然后select监听该通道可以实现

## 8.共享变量

### 互斥锁

go在语言层面支持了互斥锁sync.Mutex，加锁和解锁过程如下，其余用法和cpp中没有大区别

```go
    mu sync.Mutex
    mu.Lock()
    mu.Unlock()
```

### 读写锁

go中也有类似读写锁的东西，为sync.RWMutex,用法如下
```go
var mu sync.RWMutex
mu.Rlock() //读锁
mu.RUnlock() //读解锁

mu.Lock() //写锁
mu.Unlock() //写解锁
```

在读竞争激烈时才有优势，否则，读写锁的代价比互斥锁要高，因此大部分情况采用互斥锁

### 延迟初始化sync.Once

类似pthread_once，保证变量被初始化一次，可以用于延迟初始化等场景

```go
var loadIconOnce sync.Once
loadIconOnce.Do(function-name)
```

### goroutine与线程（重要！！！）

* 可增长的栈  
    对于线程来说都有一个固定大小的栈，一般为2MB，对于一个小的goroutine，可能只是完成一个很小的任务，2MB的栈太过庞大。而对于一个很复杂的任务或深度递归的函数，2MB却有可能爆栈。

    作为对比，goroutine在生命开始只有一个很小的栈（典型为2KB），如果需要的话，goroutine的栈可以按需增大或减小，最大限制可以达到1GB。

* goroutine调度  
    线程调度是由os内核来调度的(如cfs调度器等)，会进行完整的上下文切换，这部分操作比较消耗时间

    go运行时采用的是自己的调度器，被称为m:n调度，可以复用m个goroutine到n个os线程中

    go的调度触发不会定时触发，而是由go语言的特定结构触发。当goroutine休眠时，调度器会将其设置，并且运行其他goroutine，因为切换不需要陷入内核态，所以切换成本低很多

## 9.反射

反射功能由reflect包提供，它定义了两个重要的类型：Type和Value。Type表示Go语言的一个类型，有许多方法。

### Type和Value

调用reflect.TypeOf函数可以把接收任何interface{}参数，并以reflect.Type形式返回(返回的是接口对应的动态类型，所以总是具体类型，而不是接口类型)

另一个重要的类型就是Value，reflect.Value可以包含一个任意类型的值。reflect.ValueOf会返回interface{}的具体值。

reflect.Value的Kind方法返回的是底层类型，可以用来区分不同的类型
