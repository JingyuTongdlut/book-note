
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

- [ 1.编程语言
](#1编程语言)
  - [ 1.1第一章c++编程常用技术  
](#11第一章c编程常用技术)
    - [ 1.11第一个c++程序
](#111第一个c程序)
    - [ 1.12函数
](#112函数)
    - [ 1.13数组
](#113数组)
    - [ 1.14指针
](#114指针)
    - [ 1.16结构体、共用体、枚举
](#116结构体-共用体-枚举)
    - [ 1.17预处理
](#117预处理)
  - [  1.2第二章面向对象的c++
](#12第二章面向对象的c)
    - [ 1.21类与对象
](#121类与对象)
    - [ 1.22继承与派生
](#122继承与派生)
    - [ 1.23类的多态
](#123类的多态)
  - [  1.3第三章常用STL的使用
](#13第三章常用stl的使用)
    - [ 1.34map
](#134map)
- [ 2.编译原理和调试
](#2编译原理和调试)
  - [ 2.1编译
](#21编译)
    - [ 2.11编译与链接
](#211编译与链接)
    - [ 2.12makefile的撰写
](#212makefile的撰写)
    - [ 2.13目标文件
](#213目标文件)
  - [ 2.2调试
](#22调试)
    - [ 2.21 strace
](#221-strace)
    - [ 2.22 gdb
](#222-gdb)
- [ 3.网络相关
](#3网络相关)
  - [ 3.1TCP协议
](#31tcp协议)
    - [ 3.11TCP协议
](#311tcp协议)

<!-- /code_chunk_output -->



# 1.编程语言
本部分介绍编程语言方面的知识，包括函数、函数重载、函数模板、数组、指针、引用、结构体和预处理的使用；面向对象的介绍，包括类的使用、继承与派生和类的多态；常用STL的介绍，包括string、vector、map和set的使用方法和原理。

## 1.1第一章c++编程常用技术  
本章主要介绍c++相关内容

### 1.11第一个c++程序
* include<>和include""的区别   
include<>常用来包含系统提供的头文件，编译器会到保存系统标准头文件的位置查找头文件   
include""常用来包含程序员自己编写的头文件，用这种格式时，编译器先查找当前目录是否有指定头文件，再从标准目录中查找

### 1.12函数
* 函数重载   
c++允许同一函数名定义多个函数，但这些函数必须参数个数不同，或者参数类型不同
* 函数模板   
通过一个虚拟的类型来代表函数的形参或函数类型，构造一个通用函数，定义函数模板的一般格式为：`template<typename T>`

### 1.13数组
* 字符数组   
用来存放字符数据的数组，实例如下：   
`char str[10] = "Book";`   
str就是字符数组，c++中用`'\0'`来标识字符串的结束，这里`str[4] ~str[9]`都是。   
用strlen()可以计算字符串的长度，返回有效字母的个数，这里是4。且strlen是一个函数，运行是计算   
对比，sizeof统计的是占用内存大小，这里是10。且sizeof是运算符，而不是一个函数，在编译时就计算好了

### 1.14指针
* 数组与指针   
数组名代表数组第一个元素的地址，即指向该数组首元素的指针   
* 数组指针，也称行指针   
定义`int (*p)[n]`;因为()的优先级高，所以，首先p是一个指针，再声明p是一个指向n维向量的指针
* 指针数组
定义`int *p[n]`;且[]的优先级高，那么首先声明p是一个数组，并且每个元素都是一个整型指针
* 字符串与指针
  * 字符串指针本身是一个变量，但他所指的字符串是常量
  * 字串存放在以首字母为首的连续区域，以`\0`结尾
* 函数与指针
函数指针是指向函数的指针(指向函数的入口地址)，声明方法如下：
`返回值类型 (*指针变量名)([形参列表])`
调用：
`(*指针变量名)([形参列表])`
* 引用
给变量取别名，效率高。用作形参不更改值时，尽量声明为常引用`const type &name = targetname`
### 1.16结构体、共用体、枚举
* 共用体
在共用体内可以定义多种数据类型，这些数据段共享一段内存，在不同时间可以保存不同数据类型和长度的变量，以节省空间，但同一时间只能使用一个成员变量的值，声明:
```
union tpyename {
  type name;
  type name;
  ...
}name
```
可以用union判断系统是big endian(大端)还是little endian(小端)
```
union Test {
  short a;
  char b[sizeof(short)];
}
...
```
### 1.17预处理
  * 宏定义
  将一个标识符定义为一个字符串，分为简单和带参两种
  简单：`#define 宏名 字符串`
  带参：`#define 宏(参数列表) 宏`
  **注意事项**
    1. 字串为表达式时，需要加上括号，避免误解
    2. 使用带参宏定义时，容易误解，也需加括号
  * `do...while(0)`的妙用
  在某些宏定义中不用循环的地方，也会用到`do...while(0)`，例如:
```
1.
#define Foo(x) do {
  statement one;
  statement two;
}while(0)
2.
#define Foo(x) {
  statement one;
  statement two;
}
```  
1是非复合语句，二是复合语句，在例如`if... else`的地方，可能会当成一个语句，出现问题
* 条件编译
可以使一部分内容只在满足一定条件时才进行编译
```
#ifdef 标识符
    code1
#else
    code2
#endif
```
* extern"C"块的应用
经常能在c和c++混编的程序中，看到这样的语句：
```
#ifdef _cplusplus
    extern "C" {
#endif
    ...
#ifdef _cplusplus
}
#endif
```
`_cpluspluss`是c++定义的宏，这种方式可以告诉编译器按C标准编译
##  1.2第二章面向对象的c++
### 1.21类与对象
* struct默认的权限是public，class默认的为private
* 析构函数
在对象生命周期结束时自动执行，实际有以下几种：
  1. 如果在函数中定义了一个对象，函数结束时，执行析构，释放对象
  2. static局部对象，当main函数结束或exit时，才执行析构
  3. 全局对象类似2
  4. 用new建立的对象，在delete释放该对象时，执行析构
* 静态数据成员
有时需要为某个类所有对象分配一个单一的存储空间。这时可以使用静态数据成员，静态成员声明后必须被定义，否则会报错。c++静态数据成员被所有对象共享(无论是基类还是)。
静态成员不占用对象的内存空间
* 静态成员函数
在类中声明函数的前面加static就成为了静态成员函数
静态成员函数没有this指针，但是和非静态相比，可以直接访问静态数据成员，因此，静态成员函数一般只引用静态数据成员
### 1.22继承与派生
* 派生类构造函数
  1. 对基类和子对象(其他类的对象)必须在成员初始化列表中进行
  2. 必须先基类构造、子对象构造、派生类构造函数体
  3. 当派生类有多个基类时，调用顺序取决于派生类声明的顺序，和初始化列表中的顺序无关
  4. 每个派生类只负责直接基类的构造
  5. 如子对象构造顺序取决于定义顺序
  6. 基类构造需要参数时，派生类必须定义构造
  7. 当所有基类和子对象都不需要参数时，派生类可以不定义构造
### 1.23类的多态
* 多态
具有不同功能的函数可以共用一个同一个函数名
利用虚函数可以利用一个**指向基类的指针**实现多态，根据指向对象的不同，调用不同的虚函数
* 虚函数的用法
  1. 用virtual关键词声明
  2. 在派生类定义的函数，函数名、函数类型、函数参数个数和类型全部与基类的虚函数相同。
  3. 定义一个指向基类的指针，并使用他指向同族中需要调用函数的对象
* 纯虚函数
纯虚函数是在基类中声明的函数，但他在基类中没有定义，如下所示：`virtal void function() = 0`
**含有纯虚函数的类为抽象类，不能生成对象**
* 构造和析构函数
构造函数不能被声明为虚函数，因为编译器在构造时，必须知道确切的类型
析构函数可以声明为虚函数（c++明确指出，当派生类对象由一个指向基类的指针被删除时，基类的析构如果非虚，派生类的成分不会被销毁，造成泄漏）
* 虚函数表(Virtual Table)
如果基类指针指向不同的派生类，则它调用同一个函数就可以实现不同的逻辑，这种机制可以让基类指针有“多种形态”，它的实现依赖于虚函数表。虚函数表（Virtual Table）是指在每个包含虚函数的类中都存在着一个函数地址的数组。
首先我们要知道虚函数表的地址总是存在于对象实例中最前面的位置，其后依次是对象实例的成员。
假设有定义`Base b;`那么虚函数表的地址vtptr的值就是`(int*)*(int*)&b`,编译器根据指向不同实例的虚表来调用相应的函数。同属一个类的对象共享一份虚函数表，vtptr指针值时相同的
##  1.3第三章常用STL的使用
STL是一个标准模板库，本章将介绍常用的内容
### 1.34map
自动建立key-value的一一对应关系，可以使用`map<key, value>  m`来定义。
key必须要支持<操作符，可以在logN的复杂度内查找到想要的内容
map采用红黑树实现
* map的插入
用insert插入pair、value_type和用数组方式插入。前两种不会覆盖，数组方式将会覆盖原值
* map的查找
一种用count判断关键词是否出现，一种用find来返回数据出现的迭代器。
* map的删除
用erase方法可以删除map的元素`map.erase(key)`，也可以为迭代器，也可以用两个迭代器删除一段，如`map.erase(b, 3)`
* map的排序
map默认按照key从小到大排序，查看map的定义：
`template <class Key, class T, class Compare  = less<key>, class Allocator = allocator<pair<const Key, T>>> class map`
第三个即为比较函数，可以替换为greater比较，也可以换成自己定义的比较函数对象
# 2.编译原理和调试
介绍编译原理相关知识，如Makefile的编写、目标文件内容与处理目标文件相关工具的使用；调试方法介绍strace分析系统调用、用gdb调试与分析coredump文件、用top分析负载情况、用ps查看系统进程和valgrind工具分析进程的内存使用情况
## 2.1编译
### 2.11编译与链接
编译与链接可以分为四个部分：预处理、编译、汇编和链接。
* 预处理
  1. 处理以#开头的预编译指令
  2. 过滤所有注释
  3. 添加行号和文件名标识，用于产生错误和警告时，能显示行号
  4. 保留所有的`#program`编译器指令，因为编译时要用到
* 编译
编译器将高级语言翻译成及其可以执行的指令和数据
* 链接
把每个模块独立地编译，然后按照要求将他们组装起来，就是链接。链接分为静态和动态
  * 静态链接
  对函数库的链接放在编译时期完成。所以相关的目标文件和涉及的函数库被合成一个可执行文件。
  * 动态链接
  可以把一些库函数的链接推迟到程序运行时期，这就是动态链接库((dynamic link library)，文件扩展名为 .so
动态链接库有利于进程间资源共享，使程序升级变得简单，链接载入完全有代码控制，但由于静态库编译时已经加载，因此会更快一点。
### 2.12makefile的撰写
makefile主要结构如下：
```
A: B
  <command>
  <command>
```
一个简单的例子
```
helloworld:file1.o file2.o
	g++ file1.o file2.o -o helloworld

file2.o:file2.cpp
	g++ -c file2.cpp -o file2.o

file1.o:file1.cpp file1.h
	g++ -c file1.cpp -o file1.o

clean:
	rm -rf *.o helloworld
```
可以看到，上述例子中，有许多重复的g++，可以把它写到一个变量里，如下：
```
OBJS = file1.o file2.o
XX = g++
CFLAGS = -Wall -O -g

helloworld : $(OBJS)
	$(XX) $(OBJS) -o helloworld

file2.o : file2.cpp file1.h
	$(XX) $(CFLAGS) -c file2.cpp -o file2.o

file1.o : file1.cpp file1.h
	$(XX) $(CFLAGS) -c file1.cpp -o file1.o

clean:
	rm -rf *.o helloworld
```
上述例子还是不够方便，介绍几个东西，利用函数使其更加方便。
几个常用的自动变量:
```
$<:第一个依赖文件
$@:目标
$^:所有不重复依赖文件以空格分开
```
两个函数wildcard和patsubst:
```
wildcard:
扩展通配符，搜索指定文件。例如src=$(wildcard./*.c)搜索所有当前目录的.c文件
patsubst:
替换通配符，按照指定规则做替换。共有三个参数，第一个为需要匹配的式样，第二个表示用什么来替换，第三个是需要被处理的由空格分开的列表。
例如obj = $(patsubst %.c, %.o, $(src))吧src里的.c换成.o
```
利用`make clean`来将目标文件和中间文件（如.o）清楚，留下干净的空间:
```
.PHONY : clean
clean:
  rm -rf *.o target
```
如果没有clean文件，那么每次make该目标的时候，都将执行，但如果目录中出现了clean文件，那么将永远不会被执行。为了避免这种情况，在前面加上`.PHONY: clean`，声明clean为伪文件，这样，确保每次`make clean`都能够执行。
### 2.13目标文件
ELF是一种用于二进制问价、可执行文件、目标代码、共享库和核心转储的标准文件格式。
* ELF的三种文件类型
  * 可重定位的目标文件
  由汇编器生成的.o文件，连接器用一个或多个可重定位目标文件作为输入，生成一个*可执行的目标文件*或者*可被共享的对象文件(.so)*
  * 可执行的目标文件
  文本编辑器vi，调试工具gdb等都是可执行的目标文件。可执行的脚本不是可执行的目标文件，他们的解释器，如bash shell才是。
  * 可被共享的目标文件
  动态库文件，即.so文件。使用动态库不需要对每个可执行程序生成一份库代码的拷贝。具体有两个步骤：1. 链接器生成.so文件，或利用.o和.so生成可执行目标文件 2. 运行时，动态链接器拿它和一个可执行的目标文件以及一些其他共享目标文件一起处理，在Linux系统里创建一个进程映像。
* ELF内容
利用`file`命令，可以查看文件类型
  * ELF头部
  利用`readelf -h add.o`可以显示add.o文件头的信息，但是不支持显示archive文档。
    * Entry point address显示文件进入点（程序执行后，第一条执行的指令），可重定位文件只提供再链接，为0x0，不存在进入点.可执行文件和动态库都存在进入点。
      1. text section里装载了可执行的代码
    * section（节区）：ELF文件用来装载内容数据的最小容器，每一个section内撞在了属性性质一样的内容

      2. data section里装载了被初始化的数据
      3. bss section里装载了未被初始化的数据
      4. 。。。
    * .o文件的section里，没有program headers，但是.o和.so不为0.
  * ELF的.text section
  可以使用`read -S`打印section表，用`readelf -x` 打印不同section中的内容，但是都是机器码。可以用`objdump`工具进行反汇编，执行`objdump -d -j .text add.o`指定-d由-j指定的section进行反汇编
## 2.2调试
主要由两种方式：
1. 在程序中插入打印语句，可以显示程序动态过程，但是效率低
2. 借用调试工具，如c++调试工具GDB
### 2.21 strace
strace通过跟踪系统调用让开发者知道程序在后台所做的事情。
* strace初识
`strace ./test`可以用strace调用执行，输出结果的每一行都是一个系统调用。
* strace跟踪信号
strace结果可以用来观察进程接收信号的情况
* -c参数可以用来统计系统调用
可以用来统计系统函数被调用次数、消耗时间等等。
### 2.22 gdb
gdb功能主要体现在：
1. 启动程序，用户可以自定义随心所欲的启动程序
2. 可以让被调试的程序在指定的断点处停住
3. 程序停住时，可以检查此时的运行状态
4. 动态的改变程序的执行环节

要调试c/c++程序，必须要把调试信息加到可执行文件中，使用编译器-g参数可以做到。
启动gdb的三种方法：
1. `gdb program`
2. `gdb program core`core文件尾程序非法执行后，core dump后产生的文件
3. `gdb program 1234`指定服务程序运行时的ID

* gdb常用用法
l:列出函数代码及其行数
b n:在第n行设置断点
b fun:在fun函数处设置断点
r:运行程序
n:单条执行
q:退出
* ps
ps(process status)命令列出当前进程的快照
  * Linux上进程有五种状态：
  1. 运行（正在运行、在运行队列中等待）
  2. 中断（休眠中，等待某个条件形成，或接收到信号
  3. 不可中断（收到信号不唤醒和不可运行，需等待到有中断发生
  4. 僵死（进程终止，但进程描述符存在，等待wait后释放）
  5. 停止，收到相应信号后停止运行
# 3.网络相关
## 3.1TCP协议
### 3.11TCP协议
* 七层网络模型
* 五层网络模型
1. 应用层：确定进程之间的通信性质，以满足用户需求。
2. 传输层：负责主机间不同进程的通信，有TCP，UDP等。传输单位为报文段或用户数据报
3. 网络层：负责分组交换网中不同主机间的通信。
4. 数据链路层：负责网络层的IP数据报组成帧。
5. 物理层：透明的传输比特流。
* 四层网络模型 TCP/IP分层模型
1. 网络接口层：包括用于协作IP数据在已有网络介质上传输的协议
2. 网间层：对应OSI七层中的网络层，包含IP协议，RIP协议，负责数据的包装、寻址和路由。还包含ICMP（Internet Control Message Protocol，网间控制报文协议）来提供网络诊断信息。
3. 传输层：对应OSI七层中的传输层，提供端到端的通信服务，包含TCP以及UDP。
4. 应用层，对应OSI七层的应用层和表示层
* TCP头部
![TCP头部](/assets/TCP头部.jpg)
