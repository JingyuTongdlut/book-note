
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

- [1.编程语言](#1编程语言)
  - [1.1第一章c++编程常用技术](#11第一章c编程常用技术)
    - [1.11第一个c++程序](#111第一个c程序)
    - [1.12函数](#112函数)
    - [1.13数组](#113数组)
    - [1.14指针](#114指针)
    - [1.16结构体、共用体、枚举](#116结构体共用体枚举)
    - [1.17预处理](#117预处理)
  - [1.2第二章面向对象的c++](#12第二章面向对象的c)
    - [1.21类与对象](#121类与对象)
    - [1.22继承与派生](#122继承与派生)
    - [1.23类的多态](#123类的多态)
  - [1.3第三章常用STL的使用](#13第三章常用stl的使用)
    - [1.34map](#134map)
- [2.编译原理和调试](#2编译原理和调试)
  - [2.1编译](#21编译)
    - [2.11编译与链接](#211编译与链接)
    - [2.12makefile的撰写](#212makefile的撰写)
    - [2.13目标文件](#213目标文件)
  - [2.2调试](#22调试)
    - [2.21 strace](#221-strace)
    - [2.22 gdb](#222-gdb)
- [3.网络相关](#3网络相关)
  - [3.1TCP协议](#31tcp协议)
    - [3.11TCP协议](#311tcp协议)
  - [3.2网络IO模型](#32网络io模型)
    - [3.21网络IO模型](#321网络io模型)
    - [3.22select函数](#322select函数)
    - [3.23poll函数](#323poll函数)
    - [3.24epoll函数](#324epoll函数)
    - [3.25select/poll/epoll的区别](#325selectpollepoll的区别)

<!-- /code_chunk_output -->



# 1.编程语言
本部分介绍编程语言方面的知识，包括函数、函数重载、函数模板、数组、指针、引用、结构体和预处理的使用；面向对象的介绍，包括类的使用、继承与派生和类的多态；常用STL的介绍，包括string、vector、map和set的使用方法和原理。

## 1.1第一章c++编程常用技术  
本章主要介绍c++相关内容

### 1.11第一个c++程序
* include<>和include""的区别   
include<>常用来包含系统提供的头文件，编译器会到保存系统标准头文件的位置查找头文件   
include""常用来包含程序员自己编写的头文件，用这种格式时，编译器先查找当前目录是否有指定头文件，再从标准目录中查找

### 1.12函数
* 函数重载   
c++允许同一函数名定义多个函数，但这些函数必须参数个数不同，或者参数类型不同
* 函数模板   
通过一个虚拟的类型来代表函数的形参或函数类型，构造一个通用函数，定义函数模板的一般格式为：`template<typename T>`

### 1.13数组
* 字符数组   
用来存放字符数据的数组，实例如下：   
`char str[10] = "Book";`   
str就是字符数组，c++中用`'\0'`来标识字符串的结束，这里`str[4] ~str[9]`都是。   
用strlen()可以计算字符串的长度，返回有效字母的个数，这里是4。且strlen是一个函数，运行是计算   
对比，sizeof统计的是占用内存大小，这里是10。且sizeof是运算符，而不是一个函数，在编译时就计算好了

### 1.14指针
* 数组与指针   
数组名代表数组第一个元素的地址，即指向该数组首元素的指针   
* 数组指针，也称行指针   
定义`int (*p)[n]`;因为()的优先级高，所以，首先p是一个指针，再声明p是一个指向n维向量的指针
* 指针数组
定义`int *p[n]`;且[]的优先级高，那么首先声明p是一个数组，并且每个元素都是一个整型指针
* 字符串与指针
  * 字符串指针本身是一个变量，但他所指的字符串是常量
  * 字串存放在以首字母为首的连续区域，以`\0`结尾
* 函数与指针
函数指针是指向函数的指针(指向函数的入口地址)，声明方法如下：
`返回值类型 (*指针变量名)([形参列表])`
调用：
`(*指针变量名)([形参列表])`
* 引用
给变量取别名，效率高。用作形参不更改值时，尽量声明为常引用`const type &name = targetname`
### 1.16结构体、共用体、枚举
* 共用体
在共用体内可以定义多种数据类型，这些数据段共享一段内存，在不同时间可以保存不同数据类型和长度的变量，以节省空间，但同一时间只能使用一个成员变量的值，声明:
```
union tpyename {
  type name;
  type name;
  ...
}name
```
可以用union判断系统是big endian(大端)还是little endian(小端)
```
union Test {
  short a;
  char b[sizeof(short)];
}
...
```
### 1.17预处理
  * 宏定义
  将一个标识符定义为一个字符串，分为简单和带参两种
  简单：`#define 宏名 字符串`
  带参：`#define 宏(参数列表) 宏`
  **注意事项**
    1. 字串为表达式时，需要加上括号，避免误解
    2. 使用带参宏定义时，容易误解，也需加括号
  * `do...while(0)`的妙用
  在某些宏定义中不用循环的地方，也会用到`do...while(0)`，例如:
```
1.
#define Foo(x) do {
  statement one;
  statement two;
}while(0)
2.
#define Foo(x) {
  statement one;
  statement two;
}
```  
1是非复合语句，二是复合语句，在例如`if... else`的地方，花括号方式可能会出现语法错误。
* 条件编译
可以使一部分内容只在满足一定条件时才进行编译
```
#ifdef 标识符
    code1
#else
    code2
#endif
```
* extern"C"块的应用
经常能在c和c++混编的程序中，看到这样的语句：
```
#ifdef _cplusplus
    extern "C" {
#endif
    ...
#ifdef _cplusplus
}
#endif
```
`_cpluspluss`是c++定义的宏，这种方式可以告诉编译器按C标准编译
##  1.2第二章面向对象的c++
### 1.21类与对象
* struct默认的权限是public，class默认的为private
* 析构函数
在对象生命周期结束时自动执行，实际有以下几种：
  1. 如果在函数中定义了一个对象，函数结束时，执行析构，释放对象
  2. static局部对象，当main函数结束或exit时，才执行析构
  3. 全局对象类似2
  4. 用new建立的对象，在delete释放该对象时，执行析构
* 静态数据成员
有时需要为某个类所有对象分配一个单一的存储空间。这时可以使用静态数据成员，静态成员声明后必须被定义，否则会报错。c++静态数据成员被所有对象共享(无论是基类还是)。
静态成员不占用对象的内存空间
* 静态成员函数
在类中声明函数的前面加static就成为了静态成员函数
静态成员函数没有this指针，但是和非静态相比，可以直接访问静态数据成员，因此，静态成员函数一般只引用静态数据成员
### 1.22继承与派生
* 派生类构造函数
  1. 对基类和子对象(其他类的对象)必须在成员初始化列表中进行
  2. 必须先基类构造、子对象构造、派生类构造函数体
  3. 当派生类有多个基类时，调用顺序取决于派生类声明的顺序，和初始化列表中的顺序无关
  4. 每个派生类只负责直接基类的构造
  5. 如子对象构造顺序取决于定义顺序
  6. 基类构造需要参数时，派生类必须定义构造
  7. 当所有基类和子对象都不需要参数时，派生类可以不定义构造
### 1.23类的多态
* 多态
具有不同功能的函数可以共用一个同一个函数名
利用虚函数可以利用一个**指向基类的指针**实现多态，根据指向对象的不同，调用不同的虚函数
* 虚函数的用法
  1. 用virtual关键词声明
  2. 在派生类定义的函数，函数名、函数类型、函数参数个数和类型全部与基类的虚函数相同。
  3. 定义一个指向基类的指针，并使用他指向同族中需要调用函数的对象
* 纯虚函数
纯虚函数是在基类中声明的函数，但他在基类中没有定义，如下所示：`virtal void function() = 0`
**含有纯虚函数的类为抽象类，不能生成对象**
* 构造和析构函数
构造函数不能被声明为虚函数，因为编译器在构造时，必须知道确切的类型
析构函数可以声明为虚函数（c++明确指出，当派生类对象由一个指向基类的指针被删除时，基类的析构如果非虚，派生类的成分不会被销毁，造成泄漏）
* 虚函数表(Virtual Table)
如果基类指针指向不同的派生类，则它调用同一个函数就可以实现不同的逻辑，这种机制可以让基类指针有“多种形态”，它的实现依赖于虚函数表。虚函数表（Virtual Table）是指在每个包含虚函数的类中都存在着一个函数地址的数组。
首先我们要知道虚函数表的地址总是存在于对象实例中最前面的位置，其后依次是对象实例的成员。
假设有定义`Base b;`那么虚函数表的地址vtptr的值就是`(int*)*(int*)&b`,编译器根据指向不同实例的虚表来调用相应的函数。同属一个类的对象共享一份虚函数表，vtptr指针值时相同的
##  1.3第三章常用STL的使用
STL是一个标准模板库，本章将介绍常用的内容
### 1.34map
自动建立key-value的一一对应关系，可以使用`map<key, value>  m`来定义。
key必须要支持<操作符，可以在logN的复杂度内查找到想要的内容
map采用红黑树实现
* map的插入
用insert插入pair、value_type和用数组方式插入。前两种不会覆盖，数组方式将会覆盖原值
* map的查找
一种用count判断关键词是否出现，一种用find来返回数据出现的迭代器。
* map的删除
用erase方法可以删除map的元素`map.erase(key)`，也可以为迭代器，也可以用两个迭代器删除一段，如`map.erase(b, 3)`
* map的排序
map默认按照key从小到大排序，查看map的定义：
`template <class Key, class T, class Compare  = less<key>, class Allocator = allocator<pair<const Key, T>>> class map`
第三个即为比较函数，可以替换为greater比较，也可以换成自己定义的比较函数对象
# 2.编译原理和调试
介绍编译原理相关知识，如Makefile的编写、目标文件内容与处理目标文件相关工具的使用；调试方法介绍strace分析系统调用、用gdb调试与分析coredump文件、用top分析负载情况、用ps查看系统进程和valgrind工具分析进程的内存使用情况
## 2.1编译
### 2.11编译与链接
编译与链接可以分为四个部分：预处理、编译、汇编和链接。
* 预处理
  1. 处理以#开头的预编译指令
  2. 过滤所有注释
  3. 添加行号和文件名标识，用于产生错误和警告时，能显示行号
  4. 保留所有的`#program`编译器指令，因为编译时要用到
* 编译
编译器将高级语言翻译成及其可以执行的指令和数据
* 链接
把每个模块独立地编译，然后按照要求将他们组装起来，就是链接。链接分为静态和动态
  * 静态链接
  对函数库的链接放在编译时期完成。所以相关的目标文件和涉及的函数库被合成一个可执行文件。
  * 动态链接
  可以把一些库函数的链接推迟到程序运行时期，这就是动态链接库((dynamic link library)，文件扩展名为 .so
动态链接库有利于进程间资源共享，使程序升级变得简单，链接载入完全有代码控制，但由于静态库编译时已经加载，因此会更快一点。
### 2.12makefile的撰写
makefile主要结构如下：
```
A: B
  <command>
  <command>
```
一个简单的例子
```
helloworld:file1.o file2.o
	g++ file1.o file2.o -o helloworld

file2.o:file2.cpp
	g++ -c file2.cpp -o file2.o

file1.o:file1.cpp file1.h
	g++ -c file1.cpp -o file1.o

clean:
	rm -rf *.o helloworld
```
可以看到，上述例子中，有许多重复的g++，可以把它写到一个变量里，如下：
```
OBJS = file1.o file2.o
XX = g++
CFLAGS = -Wall -O -g

helloworld : $(OBJS)
	$(XX) $(OBJS) -o helloworld

file2.o : file2.cpp file1.h
	$(XX) $(CFLAGS) -c file2.cpp -o file2.o

file1.o : file1.cpp file1.h
	$(XX) $(CFLAGS) -c file1.cpp -o file1.o

clean:
	rm -rf *.o helloworld
```
上述例子还是不够方便，介绍几个东西，利用函数使其更加方便。
几个常用的自动变量:
```
$<:第一个依赖文件
$@:目标
$^:所有不重复依赖文件以空格分开
```
两个函数wildcard和patsubst:
```
wildcard:
扩展通配符，搜索指定文件。例如src=$(wildcard./*.c)搜索所有当前目录的.c文件
patsubst:
替换通配符，按照指定规则做替换。共有三个参数，第一个为需要匹配的式样，第二个表示用什么来替换，第三个是需要被处理的由空格分开的列表。
例如obj = $(patsubst %.c, %.o, $(src))吧src里的.c换成.o
```
利用`make clean`来将目标文件和中间文件（如.o）清楚，留下干净的空间:
```
.PHONY : clean
clean:
  rm -rf *.o target
```
如果没有clean文件，那么每次make该目标的时候，都将执行，但如果目录中出现了clean文件，那么将永远不会被执行。为了避免这种情况，在前面加上`.PHONY: clean`，声明clean为伪文件，这样，确保每次`make clean`都能够执行。
### 2.13目标文件
ELF是一种用于二进制问价、可执行文件、目标代码、共享库和核心转储的标准文件格式。
* ELF的三种文件类型
  * 可重定位的目标文件
  由汇编器生成的.o文件，连接器用一个或多个可重定位目标文件作为输入，生成一个*可执行的目标文件*或者*可被共享的对象文件(.so)*
  * 可执行的目标文件
  文本编辑器vi，调试工具gdb等都是可执行的目标文件。可执行的脚本不是可执行的目标文件，他们的解释器，如bash shell才是。
  * 可被共享的目标文件
  动态库文件，即.so文件。使用动态库不需要对每个可执行程序生成一份库代码的拷贝。具体有两个步骤：1. 链接器生成.so文件，或利用.o和.so生成可执行目标文件 2. 运行时，动态链接器拿它和一个可执行的目标文件以及一些其他共享目标文件一起处理，在Linux系统里创建一个进程映像。
* ELF内容
利用`file`命令，可以查看文件类型
  * ELF头部
  利用`readelf -h add.o`可以显示add.o文件头的信息，但是不支持显示archive文档。
    * Entry point address显示文件进入点（程序执行后，第一条执行的指令），可重定位文件只提供再链接，为0x0，不存在进入点.可执行文件和动态库都存在进入点。
      1. text section里装载了可执行的代码
    * section（节区）：ELF文件用来装载内容数据的最小容器，每一个section内撞在了属性性质一样的内容

      2. data section里装载了被初始化的数据
      3. bss section里装载了未被初始化的数据
      4. 。。。
    * .o文件的section里，没有program headers，但是.o和.so不为0.
  * ELF的.text section
  可以使用`read -S`打印section表，用`readelf -x` 打印不同section中的内容，但是都是机器码。可以用`objdump`工具进行反汇编，执行`objdump -d -j .text add.o`指定-d由-j指定的section进行反汇编
## 2.2调试
主要由两种方式：
1. 在程序中插入打印语句，可以显示程序动态过程，但是效率低
2. 借用调试工具，如c++调试工具GDB
### 2.21 strace
strace通过跟踪系统调用让开发者知道程序在后台所做的事情。
* strace初识
`strace ./test`可以用strace调用执行，输出结果的每一行都是一个系统调用。
* strace跟踪信号
strace结果可以用来观察进程接收信号的情况
* -c参数可以用来统计系统调用
可以用来统计系统函数被调用次数、消耗时间等等。
### 2.22 gdb
gdb功能主要体现在：
1. 启动程序，用户可以自定义随心所欲的启动程序
2. 可以让被调试的程序在指定的断点处停住
3. 程序停住时，可以检查此时的运行状态
4. 动态的改变程序的执行环节

要调试c/c++程序，必须要把调试信息加到可执行文件中，使用编译器-g参数可以做到。
启动gdb的三种方法：
1. `gdb program`
2. `gdb program core`core文件尾程序非法执行后，core dump后产生的文件
3. `gdb program 1234`指定服务程序运行时的ID

* gdb常用用法
l:列出函数代码及其行数
b n:在第n行设置断点
b fun:在fun函数处设置断点
r:运行程序
n:单条执行
q:退出
* ps
ps(process status)命令列出当前进程的快照
  * Linux上进程有五种状态：
  1. 运行（正在运行、在运行队列中等待）
  2. 中断（休眠中，等待某个条件形成，或接收到信号
  3. 不可中断（收到信号不唤醒和不可运行，需等待到有中断发生
  4. 僵死（进程终止，但进程描述符存在，等待wait后释放）
  5. 停止，收到相应信号后停止运行
# 3.网络相关
## 3.1TCP协议
### 3.11TCP协议
* 七层网络模型
* 五层网络模型
1. 应用层：确定进程之间的通信性质，以满足用户需求。
2. 传输层：负责主机间不同进程的通信，有TCP，UDP等。传输单位为报文段或用户数据报
3. 网络层：负责分组交换网中不同主机间的通信。
4. 数据链路层：负责网络层的IP数据报组成帧。
5. 物理层：透明的传输比特流。
* 四层网络模型 TCP/IP分层模型
1. 网络接口层：包括用于协作IP数据在已有网络介质上传输的协议
2. 网间层：对应OSI七层中的网络层，包含IP协议，RIP协议，负责数据的包装、寻址和路由。还包含ICMP（Internet Control Message Protocol，网间控制报文协议）来提供网络诊断信息。
3. 传输层：对应OSI七层中的传输层，提供端到端的通信服务，包含TCP以及UDP。
4. 应用层，对应OSI七层的应用层和表示层
* TCP头部
![TCP头部](../assets/TCP头部.jpg)
TCP头部每个字段为管理TCP连接和控制数据流起了重要作用。
1. 端口号：首先为两个16位端口号，告知主机来源和目的的端口。客户端通常使用系统自动选择的临时端口号，服务器使用知名服务端口。
2. 32位序号：每一个包中都包含序列号，在接收端则通过确认号用来通知发送端数据成功接收。当一个主机开启一个TCP会话时，它的序列号被系统初始化为某个随机值ISN。后续的TCP报文段中序号加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个TCP报文段传送的数据是字节流中的第1025～2048字节，那么该报文段的序号值就是ISN+1025。
3. 32位确认号：用作对另一方发来的TCP报文段的响应。其值是收到TCP报文段的序号值+1。
4. 4位的头部长度：标识头部有多少个32bit。
5. 6位标志位
  URG标志，标识紧急指针是否有效
  ACK标志，标识确认号是否有效，携带此标志的称为确认报文段
  PSH标志，提示接收端应立即取走数据，以腾出空间
  RST标志，要求重新建立连接，称为复位报文段
  SYN标志，请求建立一个连接，称为同步报文段
  FIN标志，通知对方本端要关闭连接，称为结束报文段
6. 16位窗口大小：用于TCP流量控制，告知对方接收缓冲区还能容纳的字节数，这样对方就可以控制发送速度。
7. 16位校验和：由发送端填充，接收端对TCP报文段执行CRC算法，已检验报文段是否损坏。TCP实现可靠传输的重要保障
8. 长度为16位，2个字节，指向后面是优先数据的字节，在URG标志设置了时才有效。如果URG标志没有被设置，紧急域作为填充。加快处理标示为紧急的数据段。
* TCP状态流转
网络上的传输是没有连接的，TCP所谓的连接指的是双方维护一个通信状态。
1. 建立连接（三次握手）
![sanciwoshou](/assets/sanciwoshou.png)
连接建立简单称为三次握手，如图所示，完成此步骤，服务器和客户端进入ESTABLISHED状态。
2. 结束连接（四次挥手）
![sicihuishou](/assets/sicihuishou.png)
TCP所示全双工的（可以同时发送和接收），因此在关闭时，需要关闭传和收两个方向的连接。 客户机给服务器发送FIN报文，服务器返回一个ACK报文，然后发送一个FIN报文，客户机恢复ACK报文后，连接结束。
**为什么建立三次，结束要四次**
因为TCP是全双工通信的，服务器收到FIN后，可能还有想要发送的数据，所以先发送ACK，告知客户请求已经被首刀，处理完后，再主动发送FIN，进入LAST_ACK阶段。主动发即使发送ACK进行确认，被动方释放连接。
* TCP超时重传
假设几种情况：1.数据顺利到对端，对端顺利响应ACK。2.数据报中途丢失。3.数据包顺利到达，但ACK报文丢失。4.数据包到达，但对端未响应ACK，或被对端丢弃。
发生异常情况,TCP会超时重传。TCP等待（RTO retransmission TimeOut，重传超时时间），若没收到ACK，则会重传这一报文段。
* TCP滑动窗口
![tcpswwindows](/assets/tcpswwindows.png)
![tcpswslide](/assets/tcpswslide.png)
TCP的窗口大小为16bit的字段，TCP选项字段里还有窗口扩大因子。TCP回话双方维护一个发送和接收窗口，接收窗口取决于系统等因素，发送取决于对端的接收窗口。
* TCP拥塞控制
计算机网络中带宽等资源时有限的，如果某一资源的需求超过的提供的部分，那么网络性能会变差，称为拥塞。TCP控制拥塞的由四个核心算法构成：慢开始、拥塞避免、快速重传和快速回复。
1. 慢开始
发送方维护一个**拥塞窗口(cwnd)** 拥塞窗口大小动态变化，发送窗口小于等于拥塞窗口。
基本思路：不要一开始就发送大量的数据，先检测一下网络的拥塞程度，也就是有小到大逐渐增加拥塞窗口大小。
为了避免cwnd增长过大，需设置慢开始门限ssthresh变量，当cwnd超过阈值，使用下述的拥塞避免算法
2. 拥塞避免
拥塞控制算法让拥塞窗口缓慢增长，每经过一个RTT将发送方cwnd+1.
具体过程如下：
TCP连接初始化，拥塞窗口设置为1
执行慢开始算法，cwnd指数增大，直到阈值，执行拥塞避免算法，cwnd线性增长
网络发生拥塞，ssthresh更新为之前的一半，cwnd重设为1
3. 快速重传
快重传要求接收方在收到一个失序的报文段后，立即发出重复确认，快重传算法规定，发送方只要一连收到3个重复确认，就当立即重传对方尚未收到的报文段，而不等待重传计时器。
4. 快恢复
当发送方连续收到三个重复确认时，执行乘法减小，将ssthresh门限减半，但不执行慢开始算法。
考虑到网络如果拥塞，将不会收到好几个重复的确认，所以发送认为网络没有拥塞，将cwnd设为ssthresh，并执行拥塞避免算法。
## 3.2网络IO模型
### 3.21网络IO模型
为了解决网络IO中的问题，有四种网络IO模型：阻塞IO模型、非阻塞IO模型、多路IO复用模型、异步IO模型
* 阻塞IO模型
![阻塞IO](/assets/阻塞IO.png)
IO操作需要等到彻底完成后才回到用户空间，这使得在此期间，线程无法执行任何运算或响应请求。
简单地改进方案是采用多线程（或多进程），这样任一个连接阻塞都不会影响其他连接。   
线程和进程严重占据系统资源，降低系统对外界响应的效率。
线程池：降低创建和销毁线程的频率，并让空闲的线程承担新的任务。
连接池：维持连接的缓存池，尽量重用已有的连接，降低创建和关闭的频率。
* 非阻塞IO模型
![非阻塞IO](/assets/非阻塞IO.png)
用户进程不断的询问kernel数据是否准备好。非阻塞的明显差别在于在被调用之后可以立即返回。
* 多路IO复用模型
![多路IO复用](/assets/多路IO复用.png)
也称事件驱动IO，它的基本原理是有个函数（如select）会不断地轮询所有负责的socket，当某个socket有数据到达了，就通知用户进程。
* 异步IO模型
![异步IO](/assets/异步IO.png)
用户发起操作后，可以作其他的是，当数据准备完成时，内核给用户进程发送信号，返回已完成的信息
### 3.22select函数
`int select(int maxfdp, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout)`
利用select监听描述符，maxfdp是最大描述符+1，timeval为设定的超时时间，返回值为准备好的描述符。
select返回后，用FD_ISSET测试该描述符是否发生事件，没发生时间的会被清空，需要重新设置。
### 3.23poll函数
和select类似，poll函数也可以用于执行多路IO复用。
```
#include<poll.h>
int poll(struct pollfd *fds, unsigned int nfds, int timeout);
```
 pollfd结构体定义如下：
```
struct pollfd {
  int fd;//文件描述符
  short events;//等待的事件
  short revents;//实际发生了的事件
}
```
每个pollfd指定一个被监视的文件描述符，在events中请求，可能在revents中返回
### 3.24epoll函数
epoll是Linux2.6内核提出的，是select和poll的增强版本。在头文件sys/epoll.h中
* epoll接口
1. int epoll_create(int size);
创建一个epoll句柄，size用来告诉内核要监听的数目。创建好后，它会占用一个fd值，所以在使用之后，必须要调用close关闭，否则可能使fd被耗尽。
2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event * event);
epoll的事件注册函数，它不同于select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。
第一个参数是create的返回值
第二个是动作，用三个宏表示：
EPOLL_CTL_ADD 注册新的fd到epfd
EPOLL_CTL_MOD 修改已经注册的fd的监听事件
EPOLL_CTL_DEL 从epfd删除一个fd
第三个参数是需要监听的fd
第四个参数是告诉内核需要监听的事情，结构体定义如下：
```
struct epoll_event {
  __uint32_t events; //epoll events
  epoll_data_t data; //user data variable
}
```
events可以是一下几个宏的集合：
EPOLLIN 表示对应描述符可读
EPOLLOUT 对应描述符可写
EPOLLPRI 对应的描述符有紧急数据可读
EPOLLERR 对应描述符发生错误
EPOLLHUP 对应描述符被挂断
EPOLLET 设置为边缘触发模式
EPOLLONESHOT 只监听一次时间
3.  int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
收集在epoll监控的事件中已经发送的事件。参数events是分配好的epoll_event结构体数组，epoll将会把发生的事件赋值到events数组中（events不可以是空指针，内核只负责把数据复制到这个events数组中，不会去帮助我们在用户态中分配内存）。maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。如果函数调用成功，返回对应I/O上已准备好的文件描述符数目，如返回0表示已超时。
### 3.25select/poll/epoll的区别
* 对于网络编程来说，一般认为poll比select高级
1. poll不要开发者在计算最大描述符+1的操作
2. poll应对大数目文件描述符时更快，因为select需要检查大量描述符对应的每一个比特位
3. select可监控的文件描述符的数目是固定的，相对较少（1024或2048）
4. select返回会使fd_set变化，每次都要重新初始化，但poll将输入输出分开，不需要重新初始化
5. select超时参数返回时未定义，考虑移植性，每次重新设置
* select的优点
1. 可移植性好，某些UNIX不支持poll
2. 对于超时值提供了更好的精度
* epoll的优点
1. 支持一个进程打开大数目的socket描述符
2. IO效率不随FD数组增加而线性下降
select和poll当有很大的socket几何时，由于网络延迟，任意时间只有部分socket是活跃的，但他们会扫描全部的几何。epoll只对活跃的socket进行操作，因为epoll是根据每个fd上面的callback函数实现的，只有活跃的socket才会调用。
3. 使用mmap加速内核和用户控件的消息传递
epoll通过内核与用户空间mmap处于同一块内存实现
