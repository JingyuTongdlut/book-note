- [Go源码剖析](#go%e6%ba%90%e7%a0%81%e5%89%96%e6%9e%90)
  - [内存分配](#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d)
    - [1.整体结构](#1%e6%95%b4%e4%bd%93%e7%bb%93%e6%9e%84)
    - [2.初始化](#2%e5%88%9d%e5%a7%8b%e5%8c%96)
    - [3.分配](#3%e5%88%86%e9%85%8d)
  - [并发调度](#%e5%b9%b6%e5%8f%91%e8%b0%83%e5%ba%a6)
    - [1.概述](#1%e6%a6%82%e8%bf%b0)
    - [2.Go程创建](#2go%e7%a8%8b%e5%88%9b%e5%bb%ba)

# Go源码剖析

先从雨痕大佬的笔记后半部开始，逐步的了解Go源码，该部分基于Go1.5.1，Linux 64位(**源码部分目前有点啃不动暂时放弃**)

## 内存分配

### 1.整体结构

整体上，内存分配分为两部分，将多个连续的页组织成span，在span内，切成多个小块，储存object对象

span采用的是简单分离存储的分离空闲链表策略，若对象超过阈值，将被当做大对象特殊处理

内存分配器最重要的是在性能和内存利用率间进行平衡，go采用的是tmalloc架构，该架构由三部分组成:

* cache: 运行线程分配cache，用来无锁分配
* central: 为cache提供分配好的后备span
* heap: 管理闲置span

分配流程大致为：从cache层开始，逐层向下搜寻，直到找到合适的空闲块。如果heap中没有合适的了，则向操作系统申请

释放流程为：将可回收object放回span.freelist，将该span放回central，以便cache使用，如果全部回收，则返回给heap，方便进行合并。heap定期扫描闲置span，释放内存

### 2.初始化

因为内存分配器和垃圾回收依赖连续地址，go在初始化阶段，会保留很大的一段虚拟地址空间(**保留虚拟地址空间，并不意味着向操作系统申请内存**)

空间分为spans，bitmap，arena三部分，三者共同对内存进行管理：

* 使用arena且仅能通过arena向操作系统申请内存，这部分大小决定了用户可分配内存的上限
* bitmap为每个对象提供4bit的标记位
* spans管理创建的span
  
arena区域被按page分片，bitmap每4位对应一个page，多个page对应一个span。虚拟内存区域的保留，是通过mmap建立映射实现的(**能够预先保留虚拟内存，主要是因为操作系统实际上并不会对申请的虚拟内存分配实际的物理内存，而是在实际用到时，触发缺页中断，此时再进行分配**)

### 3.分配

对象的分配会尽量在栈上完成，这有助于提高性能，减少垃圾回收器的压力。但是和cpp不同，go是否在栈上，和是不是用new进行分配毫无关系。

分配主要思路为：

* 大对象直接从heap获取span  
* 小对象从cache.alloc[sizeclass].freelist获取
* 微小对象组合使用cache.tiny object(这里会从span中申请获得)

## 并发调度

在运行时，go没有采用进程/线程的模式，而是进行了更高层次的抽象，称为go程

链接[Go并发原理](https://i6448038.github.io/2017/12/04/golang-concurrency-principle/)中，讲的很棒，同时分析了为什么需要P，以及怎么均衡的在多个线程M中均衡分配G

### 1.概述

M指的是Machine，一个M直接关联了一个线程。
P指的是Processor，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。
G指的是Goroutine，其实本质上也是一种轻量级的线程。
 
⾸先是 Processor（简称 P），其作⽤类似 CPU 核，⽤来控制可同时并发执⾏的任务数量。每个⼯作线程都必须绑定⼀个有效 P 才被允许执⾏任务，否则只能休眠，直到有空闲 P 时被唤醒。P 还为线程提供执⾏资源，⽐如对象分配内存、本地任务队列等。线程独享所绑定的 P 资源，可在⽆锁状态下执⾏⾼效操作。
 
进程内的⼀切都在以G⽅式运⾏，包括运⾏时相关服务，以及main.main ⼊口函数。需要指出，G 并⾮执⾏体，它仅仅保存并发任务状态，为任务执⾏提供所需栈内存空间。G 任务创建后被放置在 P 本地队列或全局队列，等待⼯作线程调度执⾏。
 
实际执⾏体是系统线程（简称 M），它和 P 绑定，以调度循环⽅式不停执⾏ G 并发任务。M 通过修改寄存器，将执⾏栈指向 G ⾃带栈内存，并在此空间内分配堆栈帧，执⾏任函数。当需要中途切换时，只要将相关寄存器值保存回 G 空间即可维持状态，任何 M 都可据此恢复执⾏。线程仅负责执⾏，不再持有状态，这是并发任务跨线程调度，实现多路复⽤的根本所在。

### 2.Go程创建

创建G后，优先放入本地P队列中，如果满了，则转移到全局队列中(其他P可能处于饥饿中)，并尝试唤醒M执行操作。

进入工作状态的M，会持续执行，直到没有任务，或者被剥夺P时，M重新进入休眠状态





