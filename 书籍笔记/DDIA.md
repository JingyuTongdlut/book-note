- [数据密集型应用系统设计(DDIA)笔记](#%e6%95%b0%e6%8d%ae%e5%af%86%e9%9b%86%e5%9e%8b%e5%ba%94%e7%94%a8%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1ddia%e7%ac%94%e8%ae%b0)
  - [数据系统基础](#%e6%95%b0%e6%8d%ae%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80)
    - [数据系统的核心问题](#%e6%95%b0%e6%8d%ae%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%a0%b8%e5%bf%83%e9%97%ae%e9%a2%98)
    - [数据模型与查询语言](#%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b%e4%b8%8e%e6%9f%a5%e8%af%a2%e8%af%ad%e8%a8%80)
    - [数据存储与检索](#%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e4%b8%8e%e6%a3%80%e7%b4%a2)
# 数据密集型应用系统设计(DDIA)笔记

除了之前学过的mysql相关的内容，对数据库知识实在是了解的很少，分布式相关的内容更是一无所知，于是买了DDIA，希望配合上[MIT6.824](https://pdos.csail.mit.edu/6.824/)，希望自己能够在数据库/分布式方面有所了解。

## 数据系统基础

### 数据系统的核心问题

大多数软件系统，有三个问题极为重要：可靠性、可扩展性以及可维护性

* 可靠性  
    可靠性意味着当出现意外情况如硬件故障、软件故障、人为失误等，系统人能正常工作(虽然性能可能略有降低)  
    但是实际应用中，需要考虑容忍故障的程度和预算见的关系，不可能用天价的预算用来容忍故障方面。  
    </b>
    接下来我们讨论一下可能发生故障的部分：
    * 硬件故障：可以通过设计冗余硬件降低单机发生失效的概率到很低，但是由于越来越多应用运行在大规模机器上，单机即使很低的概率，随着机器的增多，发生故障的概率也会增加。因此，通过软件容错的方式作为硬件容错的有力补充
    * 软件错误：硬件故障一般来说是相互独立的(除非是服务机房发生问题这种整体的问题)，而软件问题常常是关联的。  
* 可扩展性  
    可扩展性讨论的问题是，当负载增加的时候，应该如何添加计算资源来处理额外的负载

    那么首先我们需要思考的问题是，怎么描述负载？(**负载通常通过一些服务器相关的数字描述，比如每秒请求处理次数、缓存命中率、峰值活跃用户数量等**)

    对于系统性能，通常使用吞吐量、服务响应时间来描述

### 数据模型与查询语言

数据模型是软件开发最重要的部分，不仅影响软件的编写方式，还对如何思考待解决的问题有着深刻的影响  

大多数计算机应用是通过一层一层叠加数据模型来构建的，每一层都会将下层进行抽象后，通过简洁的接口来向上层提供服务

这部分将重点介绍需要存储数据结构是的抽象(采用通用数据模型，如JSON/XML、关系数据库中的表/图模型等)
* 关系模型
    在此模型中，数据被组织成关系(SQL中的表)，其中每个关系都是元组(SQL中的行)的无序集合，管理工具称为关系数据库管理系统(RDBMS)
* 非关系型数据库(NoSQL)
    NoSQL的出现主要是由于大多数应用开发采用的是面向对象的语言，如果想要用SQL进行存储，则需要在应用层代码和SQL的数据模型之间添加一个笨拙的转换层。

    对于NoSQL来说，开发人员在两个方向发展：
    * 文档数据库，适用于数据来自文档，且和其他文档见关系较少
    * 图数据库，针对所有数据都有可能相互关联的问题

对于一对多这种模式的关系(如一个人可能担任多个职位)来说，使用SQL通常会存在多个table中，依靠join多个表进行操作。如果采用文档模型，则可以很容易表示这种一对多的关系

对于多对一的情况，关系型数据库可以通过联结很容易的实现，而文档数据库一般不支持/很弱联结，所以得通过多次对数据库查询模拟联结。

### 数据存储与检索

从数据库应用的最基本层面来看，他只需要完成两个工作：插入数据并保存，查询数据时正确返回那些数据

对于类似日志形式的顺序存储结构，查询的开销为O(n)，这对于数据库系统这种大容量的数据来说并不高效，因此，为了更加高效的读取，会通过建立额外的索引来提高效率，但是对于写入，顺序写入效率意见是最高的了，因此我们需要在两方面进行权衡

* 哈希索引(Bitcask)
    对于key-value类型的数据，通常采用hash map来实现(许多语言中也有类型结构，如cpp的unordered_map)。
    一种简单的构建map的方式是把key映射到对应内容的在数据文件中的偏移量。
    通过哈希的方法，有着一些限制：
    * 哈希表必须存放在内存，如果有大量的key，那么内存就不一定够了。当然，hash map也可以存在磁盘上，但是效率很低
    * 区间查找效率不高，因为hash map是一一映射的，不能像红黑树这种结构，进行高效的区间查找
* 排序字符串表(SSTable)和日志结构的合并树(LSM-Tree)
    




