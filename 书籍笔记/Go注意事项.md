- [Go注意事项](#go%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9)
  - [数据](#%e6%95%b0%e6%8d%ae)
    - [slice](#slice)
    - [string](#string)
  - [方法](#%e6%96%b9%e6%b3%95)
    - [方法集](#%e6%96%b9%e6%b3%95%e9%9b%86)
    - [表达式](#%e8%a1%a8%e8%be%be%e5%bc%8f)
  - [接口](#%e6%8e%a5%e5%8f%a3)
    - [定义](#%e5%ae%9a%e4%b9%89)
    - [执行机制](#%e6%89%a7%e8%a1%8c%e6%9c%ba%e5%88%b6)
    - [技巧](#%e6%8a%80%e5%b7%a7)
  - [并发](#%e5%b9%b6%e5%8f%91)
    - [基础](#%e5%9f%ba%e7%a1%80)
    - [通道](#%e9%80%9a%e9%81%93)
    - [同步](#%e5%90%8c%e6%ad%a5)
  - [反射](#%e5%8f%8d%e5%b0%84)
    - [类型](#%e7%b1%bb%e5%9e%8b)
    - [值](#%e5%80%bc)

# Go注意事项

这个笔记储存Go的一些注意事项，包括平常刷题，写代码发现的，以及一些书籍中指出的，需要特别注意的。

## 数据

### slice

各种书籍和博客上总说，slice是传递引用，这句话本身并不完全对。需要完全理解slice，首先需要看看slice的结构，如下：

```go
type slice struct {
	array unsafe.Pointer //指针
	len   int //长度
	cap   int //容量
}
```

因为我们在用slice进行传递参数的时候，会对底层struct进行拷贝，所以形参和实参指向了内存的同一片区域，那么在其中进行更改的话，就会反映到实参中

但是，如果更改超出了实参的len，在实参中因为len没有改变的原因，是不会有任何体现的，同样，对cap的更改，也不会在实参中得到体现。

因为上述原因，我们在函数内对slice做append的时候，实参的len和cap没有任何改变，因此难以体现更改。**更糟糕的是，因为append有可能会导致新的内存分配，如果重新分配了内存，两个slice甚至指向的内存都不同了，那么即使在len内做的任何改变，实参都不会体现出来了。如果我们想要函数内部的改变得到体现，可以传入slice的指针解决这个问题。**



### string

* 遍历  
    对string做普通for循环和range for循环，遍历是不同的，区别如下

    ```go
    for i = 0; i < len(s); i++ { //byte

    }

    for _, ch := range s { //rune

    }
    ```

* 更改  
    string类本身是不允许修改的，想要修改字符串，只有把他们转换成可变的[]byte或[]rune，再进行修改，然后再转换为string赋值。这个操作必须重新分配内存，效率很低。
    有几种提高字符串更改效率的方式：

    * 利用`unsafe.Pointer`将[]byte地址转换成string的指针，解引用后直接传给string，这里，string直接拷贝了[]byte中的内容，避免了底层数组复制(unsafe.Pointer类似c中的void*，万能指针，但是因为GC，unsafe包不安全，应该尽可能减少使用)
    * 简单调用+=每次都会重新分配内存，效率极低，如果要拼接的存在一个slice中，我们可以利用`strings.Join()`，他会预先计算好需要分配的内存，一次性分配，提高效率(编译器会对s1+s2+s3做类似的优化)
    * bytes.Buffer是一个[]byte类型的，会自动增长的缓冲区，他提供了Write，WriteString等方法进行写入，效率也很高

## 方法

### 方法集

规范中定义了方法集的描述
|值|接收者|
|:---:|:---:|
|T|t T|
|*T|t T 和 t *T|

那么也就是说，如果接受者是T，则值类型是什么皆可，如果是指针，则只能传入指针了

所以，在我们调用接口方法是需要注意方法集的对应，这主要是因为，我们并不总是能获取值的地址，所以对于值类型，只包括了接收者为值的情况

### 表达式

方法和普通的函数一样，可以被赋值给变量，或者作为参数传递，具体expression和value两种形式

* Method Expression
    通过类型名引用的方法，会被还原成普通的函数。receiver是第一参数，调用时必须显示传参，如：

    ```go
    type N int //N has a method call test
    var n N = 10
    f1 := N.test //调用时，显示传参，f1(n)
    f2 := (*N).test //同上，显示传参，f2(&n)
    ```

    这种形式和cpp中的std::bind很类似，std::bind在绑定类的成员函数时，同样要把类的实例作为第一个参数传入，剩下的参数用placeholder占位
* Method Value
    基于实例或指针引用的method value，参数列表不会改变，依然按照正常方式调用。  

    当method value被赋值给变量或传参的时候，会立即计算并拷贝该方法所需要的receiver，进行绑定，以便之后进行调用  

    当然，如果receiver是指针，那么拷贝并绑定的也是指针。可以实现变量绑定和延迟调用。

    这种形式，和闭包基本类似，只是在赋值的时候，会绑定实例

## 接口

### 定义

接口通常用er结尾，方法名作为声明组成部分

空接口interface {}可以被赋值给任意类型的对象，类似void类型

接口可以通过嵌入匿名接口的方式，嵌入其他接口。目标类型方法集必须实现包含嵌入接口在内的所有接口才算实现了该接口(**此方法相当于导入了嵌入接口的方法，因此不能有同名接口，因为go不支持重载**)

超集接口变量可以隐式的转换为子集，反之不行

### 执行机制

接口使用itab结构存储运行期所需的相关类型信息

```go
//接口类型
type iface struct {
    tab *itab //类型信息
    data unsafe.Pointer //实际对象指针
}

//itab类型，储存iface的类型信息
type itab struct {
    inter *interfacetype //接口类型
    _type *_type //实际对象类型
    fun [1]unitptr //实际对象方法地址
}
```

接口相关结构保存了接口和实际对象的数据，同时itab里还储存了实际对象方法的地址，从而实现运行期对目标方法的调用

当对象赋值给接口时，会复制该对象。接口储存的复制品，是不可更改的，因为是unaddressable的。

需要更改的话，解决方法是，直接将对象的指针赋值给接口，这样接口储存的就是指针的复制品

只有当接口的itab和data都为nil时，接口才为nil

### 技巧

* 类型转换  
    类型推断可将接口变量还原为原始类型，或用来判断是否实现了某个更具体的接口类型，常利用ok-idiom模式，即使转换失败也不会引发panic

    ```go
    if n, ok := x.(fmt.Sringer); ok {
        fmt.Println(n)
    }
    ```

    还可以配合switch，在多种类型间进行推断,但是这种type词法只能在switch中使用

    ```go
    switch v := x.(type) {
        case nil :
        case 1: 
        default:
    }
    ```

## 并发

### 基础

goroutine通过go关键词创建，但并不是立即开始并发操作，而是进入等待队列，等待调度器的调度

goroutine初始栈很小，仅需2KB，自定义栈在需要时会进行扩容，最大可达到GB级别

与defer一样，goroutine也会因为“延迟执行”，而立即计算并复制执行参数

有时需要等待goroutine完成某些事
* 通过阻塞channel的性质，进行等待
* 通过sync.WaitGroup进行同步多个任务。调用Add增加技术，Done减小计数，Wait进行等待计数为0，类似与countDownLatch的功能(**尽管这些操作是原子操作，但仍建议在goroutine外进行Add，避免还未Add，Wait就已经退出，**)

runtime.GOMAXPROCS()可以设置同时参与并发任务执行的线程个数，默认和处理器核数相等(runtime.NumCPU可以知道)

Goexit可以立即退出当前goroutine

### 通道

go鼓励使用CSP通道，用通信来代替内存共享，实现并发安全

内置函数len和cap可以返回缓冲区已用大小和当前缓冲区容量

* 收发  
    * 简单的利用`a <- ch`和`ch <- a`进行收发
    * 利用ok-idiom判断通道是否关闭
    * range模式循环读取，直到通道关闭

* 选择  
    如果要同时处理多个通道，可以采用select语句，它会随机选取可用通道做操作，如果任一通道被关闭，则终止

    如果要等待所有通道处理结束，可以将关闭通道设为nil，阻止select选择它

    select也支持default操作
* 资源泄露  
    处于收发阻塞的通道，但一直未被唤醒，垃圾回收器不会回收资源，造成资源泄露

### 同步

标准库sync有Mutex和RWMutex以及原子操作等，可以满足日常开发的同步需求。

将Mutex作为匿名字段时，相关方法receiver必须是指针，否则会因复制，导致锁失效(因为持有的锁不相同，锁也就无用了。)除了receiver为指针，还可以通过嵌入*Mutex来保证操作的锁为同一个，但是需要另外初始化，更为麻烦

## 反射

### 类型

反射让我们能够在运行期探知对象的类型信息和内存结构，反射所需的全部信息都源自接口变量

在面对类型是，要区分Type和Kind，前者表示真实类型，后者表示其基础结构类别

基类型和指针类型不是同一个类型，需要注意

Type.Elem返回应用类型的基类型

### 值

和Type专注于类型信息不同，Value专注于对象实例的读写

接口会复制变量，且是不可寻址的，所以想要修改目标对象，必须传入指针。(**即使传入指针，也需要进一步调用Elem获取目标对象，因为接口储存的指针本身是不能寻址和设置操作的**)













