# 1. redis 概览

## 1.1 redis 基本概念

* 基于内存(快)
* key-value 模型(在不知道数据全貌的情况下，很难找出数据间的关系)
* 单线程worker(6.x 后，redis 支持 io 的多线程)
* 连接数很多，使用 epoll
* value 有类型：五种类型，相比 memcache 只支持 string，redis 类型丰富，且有本地方法，计算向数据移动(redis 侧)
  * 优点在于，如果存的是 string，那么请求是只能全量发送 data 给 client 侧，而 redis 可以根据一些方法，得到要发送的数据，再发送给客户端，对于网络更加友好
* 整体是串行化的
  * 串行的优点：对于一些操作，可能需要互斥的访问一些变量(数据库的话加锁之类的)，redis 直接采用单线程模型，将操作串行化，避免掉加锁解锁的开销，反而效率更高。
  * 串行的缺点：相对多线程程序，没有充分利用到多核 CPU，为了同时享受串行以及多核的优点，redis 支持了 io thread，具体来说，让计算串行化，但是，对于连接的读写 io，则扔到 io thread 里运行，提高效率

## 1.2 redis 应用场景

### 1.2.1 redis 数据类型

* string(字符串操作、数值操作(+-等)、二进制位(bitmap))
* list(双向链表，左右两头都可以高效插入)
  * 评论列表、消息队列
  * 有可能替代一些容器，让后端服务无状态
* hash(hash table) 
  * 聚集数据(数据需要保存多个表的，如果不怎么改变，可以缓存在 redis 里聚集起来)
  * 详情页

* sorted_set(跳表，按 score 排序，相同的话，按字典序)
  * 排行榜

# 2. redis 分布式

## 2.1 持久化

一般持久化分为两类

* Snapshot: 指的是在固定时间点上，对数据库拍一次快照，做全量的备份，也就是 Redis 中的 RDB
  * 全量备份，丢失信息较多
  * 体积相对小，恢复速度快(没啥额外计算，恢复速度基本取决于 io)
* logs: 指的是每次操作都记录一下，时间间隔趋向于实时。
  * 增量备份，丢失信息较少
  * 可以调整丢失的粒度，比如每秒 fsync 一次这样
  * 要重新执行操作，较慢

redis 默认开启 RDB，关闭 AOF，可以手动开启 AOF。当版本4.X 前，开启了 AOF 的话，redis 重启只会使用 aof。但这种方案对长时间运行的机器很不友好，因为 AOF 中有很多无用的指令，有两个方案可以解决这个问题：

* 重写(redis 早期方案)：Redis提供了文件重写的功能，通过创建一个新的AOF来替代现有的AOF文件(具体的，是扫描当前数据库，通过直接添加现有键值对的方式，即可代替过去历史的所有操作，记录当前数据库状态)。
* 使用 RDB+AOF 的方式：通过全量+增量的方式解决

## 2.2 分布式

所有单机程序，不可避免的有着以下两个问题：

* 单点故障：单机程序故障后，将不能继续提供服务
  * 使用主从集群，**全量复制**的方式实现高可用的集群(类似 raft 集群)
* 压力/性能：所以请求都达到一台机器，瓶颈受单机 qps 上限限制，或者缓存大小受单机内存限制
  * 将数据分片后，分散到多个主机中，降低单台机器的压力

上述两个步骤就是 duplica 和 sharding

### 2.2.1 duplica

主从复制一般有两种方式：

* 同步复制：主节点等待从节点复制成功后，再回复客户端，满足 CP，但是可用性大大降低
* 异步复制：主节点不需要等待

基于 redis 通常作为高性能的缓存，同步复制方案效率太低，因此默认采用异步复制的方式

## 2.2.2 sharding

一般分片有几种实现：

* 客户端做分片，浪费客户端的 CPU，而且业务逻辑和分片逻辑混淆
* 利用一个 proxy 来访问 redis 分片集群，在 proxy 处实现 sharding，对业务代码的侵入很小但是当 redis 节点较多的时候，单 proxy 压力可能过大，可能需要做负载均衡
* 还有一种更优美的方式是将分片算法，部署到 redis 节点之上，请求打到某个 redis 上后，通过算法计算出请求的 key 实际在的 redis 节点，告知客户端去那里取。
  * redis 没有使用常用的一致性 hash，而是将key 映射的值分为 16384 个 slot。每个节点负责一部分 slot，当新增或删除节点的时候，对相应的 slot 做处理即可



